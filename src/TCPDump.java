import java.io.File;
import java.util.HashMap;
import jpcap.*;
import jpcap.packet.ICMPPacket;
import jpcap.packet.IPPacket;
import jpcap.packet.Packet;
import jpcap.packet.TCPPacket;
import jpcap.packet.UDPPacket;

/**
 *
 * @author basilGeorge
 */



class TCPDump extends Thread implements PacketReceiver {

        HashMap  udp_countlast2secs = null;
        HashMap  udp_countcurrent2secs = new HashMap();

        Classification classfyengine = new  Classification();


        PacketProcessor snortp = new PacketProcessor();


        NaiveClassifier naiveCE;

        HMMClassifer mlrclassify;


        GUI guiinst;
        int [] score = new int[10];
        int [] atkcount = new int[10];
        int totattack=0;

      

       

        public void initNaiveClassfy(NaiveClassifier nvc)
        {
            naiveCE = nvc;


        }
        public void initMLRClassfy(HMMClassifer nvc)
        {
            mlrclassify = nvc;


        }



        public TCPDump(GUI inst)
        {
            guiinst = inst;
            for (int i=0;i<score.length;i++)
            {
                score[i]=0;
            }
        }

        void udpaddcountincurrent(String ipadd)
        {
            Integer cou = (Integer)udp_countcurrent2secs.get(ipadd);

            if (cou != null)
            {
                cou++;
            }



        }

        int udpaddcountinlastsecs(String ipadd)
        {
            if(udp_countlast2secs == null)
                return 0;

            Integer cou = (Integer)udp_countlast2secs.get(ipadd);

            if (cou != null)
            {
                return cou.intValue();
            }

            return 0;


        }

        STATUS invokeClassification(ConnectionAttributes ca)
        {
          
            
            STATUS result1 = naiveCE.classifyConnection(ca);
            

            return result1;

          
            //return result;


            
        }

      

        void writeClassifyResultstoFile(Packet p ,STATUS t)
        {
            writeSClassifyResultstoFile(p,t);

            
        }


       
        void writeSClassifyResultstoFile(Packet p ,STATUS t)
        {
            IPPacket  ip = (IPPacket)p;



            if (ip.protocol == IPPacket.IPPROTO_UDP) // 17)  // udp
            {
                UDPPacket udpp = (UDPPacket)p;
                String content = "P#" +  udpp.src_ip.getHostAddress() + "#" +
                                        udpp.dst_ip.getHostAddress() + "#" +
                                        udpp.src_port + "#" +
                                        udpp.dst_port + "#" + t;

                FileAppender.AppendtoFile("Packetlog.txt", content);

            }
            else if (ip.protocol == IPPacket.IPPROTO_TCP) //6) //tcp
            {
                TCPPacket  tcpp = (TCPPacket)p;
                String content = "P#" +  tcpp.src_ip.getHostAddress() + "#" +
                                        tcpp.dst_ip.getHostAddress() + "#" +
                                        tcpp.src_port + "#" +
                                        tcpp.dst_port + "#" + t;

                FileAppender.AppendtoFile("Packetlog.txt", content);

            }
            else if (ip.protocol == IPPacket.IPPROTO_ICMP)
            {
                ICMPPacket icmp = (ICMPPacket)p;

                String content = "P#" +  icmp.src_ip.getHostAddress() + "#" +
                                        icmp.dst_ip.getHostAddress() + "#" +
                                        0 + "#" +
                                        0 + "#" + t;

                FileAppender.AppendtoFile("Packetlog.txt", content);
            
            }




        }


        
        boolean checkAgainstSnortRules(IPPacket ip)
        {

            PacketInfo pinfo = new PacketInfo();




            pinfo.nwtos=Integer.toString(ip.priority);
            if (ip.protocol == IPPacket.IPPROTO_UDP)
            {
                pinfo.nwproto="UDP";
                UDPPacket udpp = (UDPPacket)ip;
                pinfo.nwsrc=udpp.src_ip.getHostAddress();
                pinfo.nwdest=udpp.dst_ip.getHostAddress();
                String tpsrc=Integer.toString(udpp.src_port);
                String tpdest=Integer.toString(udpp.dst_port);
                
                guiinst.writetolog("Checking against snort rule for UDP srcip:" + pinfo.nwsrc + " dest:" + pinfo.nwdest);

            }
            if (ip.protocol == IPPacket.IPPROTO_TCP)
            {
                pinfo.nwproto="TCP";
                TCPPacket udpp = (TCPPacket)ip;
                pinfo.nwsrc=udpp.src_ip.getHostAddress();
                pinfo.nwdest=udpp.dst_ip.getHostAddress();
                String tpsrc=Integer.toString(udpp.src_port);
                String tpdest=Integer.toString(udpp.dst_port);

                guiinst.writetolog("Checking against snort rule for TCP:" + pinfo.nwsrc + " dest:" + pinfo.nwdest);
            }
            if (ip.protocol == IPPacket.IPPROTO_ICMP)
            {
                pinfo.nwproto="ICMP";
                ICMPPacket udpp = (ICMPPacket)ip;
                pinfo.nwsrc=udpp.src_ip.getHostAddress();
                pinfo.nwdest=udpp.dst_ip.getHostAddress();

                guiinst.writetolog("Checking against snort rule for ICMP:" + pinfo.nwsrc + " dest:" + pinfo.nwdest);


            }

            boolean ret=snortp.canForwardPacket(pinfo);

            guiinst.writetolog("Snort returned  " + ret);
            return ret;
            
            


        }
        void writeSummaryResult()
        {
              try
              {
                  File fx = new File("summaryresult.txt");
                  fx.delete();
              }
              catch(Exception ex)
              {

              }

              String cth = " Total Number of attacks:" + totattack;

              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "BACK : " + atkcount[0];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "IPSWEEP:" + atkcount[1];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "GUESSPASSWD:" + atkcount[2];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "PORTSWEEP:" + atkcount[3];
              FileAppender.AppendtoFile("summaryresult.txt", cth);


              cth = "TEARDROP:" + atkcount[4];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "NMAP:" + atkcount[5];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "SMURF:" + atkcount[6];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "POD:" +atkcount[7];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "NEPTUNE:" + atkcount[8];
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              cth = "RISK Score of the Network:" + guiinst.rsk;
              FileAppender.AppendtoFile("summaryresult.txt", cth);

              
        }

        
        void calculateScore(STATUS result)
        {

             if (totattack>1000)
             {
                 return;
             }

             switch (result)
             {
                 case BACK:
                 {
                     score[0]+=1;
                     atkcount[0]++;
                     
                     totattack++;
                     break;
                 }
                 case IPSWEEP:
                 {
                     score[1]+=2;
                      atkcount[1]++;
                     totattack++;
                     break;
                 }
                 case GUESSPASSWD:
                 {
                     score[2]+=3;
                      atkcount[2]++;
                     totattack++;
                     break;
                 }
                 case PORTSWEEP:
                 {
                     score[3]+=4;
                      atkcount[3]++;
                   
                     totattack++;
                     break;
                 }
                 case TEARDROP:
                 {
                     score[4]+=5;
                      atkcount[4]++;
                     
                     totattack++;
                     break;
                 }
                 case NMAP:
                 {
                     score[5]+=6;
                      atkcount[5]++;
                    
                     totattack++;
                     break;
                 }
                 case SMURF:
                 {
                     score[6]+=7;
                     atkcount[6]++;
                     totattack++;
                     break;
                 }
                 case POD:
                 {
                     score[7]+=8;
                      atkcount[7]++;
                   
                     totattack++;
                     break;
                 }
                 case NEPTUNE:
                 {
                     score[8]+=9;
                      atkcount[8]++;
                    
                     totattack++;
                     break;
                 }

             }
             int totsc=0;
             for (int i=0;i<10;i++)
             {
                 totsc = totsc+score[i];
             }

             double sc = totsc *10.0/ (1000*9);
             guiinst.rsk = sc;


             guiinst.displayScore();


        }

	public void receivePacket(Packet packet) {
		System.out.println("!!!! Recieved packet " + packet);
                
                IPPacket  ip = (IPPacket)packet;

                /*
                boolean res=checkAgainstSnortRules(ip);

                if (res==false)
                {

                    System.out.println("Snort rule denied");

                    return;


                }
                */

                if (ip.protocol == IPPacket.IPPROTO_UDP) // 17)  // udp
                {
                    UDPPacket udpp = (UDPPacket)packet;

                    System.out.println("********Recieved UDP Packet");

                    System.out.println("Src IP: " + udpp.src_ip.getHostAddress());

                    System.out.println("Dest IP:" + udpp.dst_ip.getHostAddress());


                    System.out.println("Src port: " + udpp.src_port);

                    System.out.println("Dest port:" + udpp.dst_port);

                    System.out.println("Src bytes:" + udpp.data.length);





                    //udpp.data[0];
                    String hdrcon = new String(udpp.data);
                    System.out.println("udp data content" + hdrcon);
                    

                    ConnectionAttributes ca = new ConnectionAttributes();

                    ca.src_bytes  =  udpp.data.length;

                    ca.protocoltype = IPPacket.IPPROTO_UDP;

                    ca.service = udpp.data[0];

                    System.out.println("Service:" + ca.service);

                    //ca.service

                    ca.dst_host_serror_rate = 0;
                    ca.dst_host_srv_serror_rate = 0;
                    ca.dst_host_rerror_rate = 0;

                    synchronized(TCPDump.class)
                    {
                       String ipadd = udpp.dst_ip.getHostAddress();

                       udpaddcountincurrent(ipadd);

                       ca.count = udpaddcountinlastsecs(ipadd);

                        
                    }

                    STATUS result = invokeClassification(ca);

                    calculateScore(result);
                    System.out.println(" The classify result returned is " + result);

                    if (result != STATUS.NORMAL)
                    {
                        guiinst.addToAlarm(result, udpp.src_ip.getHostAddress());
                    }

                    writeClassifyResultstoFile(packet,result);
                    

                }
                else if (ip.protocol == IPPacket.IPPROTO_TCP) //6) //tcp 
                {
                    TCPPacket  tcpp = (TCPPacket)packet;

                    System.out.println(" Processing TCP packet");

                    System.out.println("Src IP: " + tcpp.src_ip.getHostAddress());

                    System.out.println("Dest IP:" + tcpp.dst_ip.getHostAddress());


                    System.out.println("Src port: " + tcpp.src_port);

                    System.out.println("Dest port:" + tcpp.dst_port);

                    System.out.println("Src bytes:" + tcpp.data.length);


                    ConnectionAttributes ca = new ConnectionAttributes();

                    ca.src_bytes  =  tcpp.data.length;

                    ca.protocoltype = IPPacket.IPPROTO_TCP;

                    ca.service = tcpp.data[0];

                    System.out.println("Service:" + ca.service);

                    //ca.service

                    ca.dst_host_serror_rate = 0;
                    ca.dst_host_srv_serror_rate = 0;
                    ca.dst_host_rerror_rate = 0;

                    //synchronized(TCPDump.class)
                    {
                       //String ipadd = udpp.dst_ip.getHostAddress();

                       //udpaddcountincurrent(ipadd);

                       ca.count = 1;  //udpaddcountinlastsecs(ipadd);


                    }

                    STATUS result = invokeClassification(ca);

                    System.out.println(" The classify result returned is " + result);

                    calculateScore(result);
                    if (result != STATUS.NORMAL)
                    {
                        guiinst.addToAlarm(result, tcpp.src_ip.getHostAddress());
                    }

                    writeClassifyResultstoFile(packet,result);
                    
                    
                }
                else if (ip.protocol == IPPacket.IPPROTO_ICMP)
                {
                     ICMPPacket icmp = (ICMPPacket)packet;

                     System.out.println(" Processing ICMP packet");

                     System.out.println("Src IP: " + icmp.src_ip.getHostAddress());

                     System.out.println("Dest IP:" + icmp.dst_ip.getHostAddress());


                    ConnectionAttributes ca = new ConnectionAttributes();

                    ca.src_bytes  =  icmp.data.length;

                    ca.protocoltype = IPPacket.IPPROTO_ICMP;

                    ca.service = 4;

                    System.out.println("Service:" + ca.service);

                    //ca.service

                    ca.dst_host_serror_rate = 0;
                    ca.dst_host_srv_serror_rate = 0;
                    ca.dst_host_rerror_rate = 0;

                    //synchronized(TCPDump.class)
                    {
                       //String ipadd = udpp.dst_ip.getHostAddress();

                       //udpaddcountincurrent(ipadd);

                       ca.count = 1;  //udpaddcountinlastsecs(ipadd);


                    }

                    STATUS result = invokeClassification(ca);

                    calculateScore(result);
                    System.out.println(" The classify result returned is " + result);

                    if (result != STATUS.NORMAL)
                    {
                        guiinst.addToAlarm(result, icmp.src_ip.getHostAddress());
                    }

                    writeClassifyResultstoFile(packet,result);


                }



	}

        public void run()
        {


             try
             {
                startRecieving(this);
                
                Thread.sleep(2000);

                synchronized(TCPDump.class)
                {
                    udp_countlast2secs = udp_countcurrent2secs;
                    udp_countcurrent2secs = new HashMap();


                }
                

             }
             catch (Exception e)
             {


             }
            
            
            
        }


	public static void startRecieving(TCPDump tcpobj) throws Exception {
		NetworkInterface[] devices = JpcapCaptor.getDeviceList();
		//if(args.length<1)
                //{
			System.out.println("usage: java Tcpdump <select a number from the following>");

			for (int i = 0; i < devices.length; i++) {
				System.out.println(i+" :"+devices[i].name + "(" + devices[i].description+")");
				System.out.println("    data link:"+devices[i].datalink_name + "("
						+ devices[i].datalink_description+")");
				System.out.print("    MAC address:");
				for (byte b : devices[i].mac_address)
					System.out.print(Integer.toHexString(b&0xff) + ":");
				System.out.println();
				for (NetworkInterfaceAddress a : devices[i].addresses)
					System.out.println("    address:"+a.address + " " + a.subnet + " "
							+ a.broadcast);
                        }
		//}
                
                System.out.println(" starting");
                        //else{
		JpcapCaptor jpcap = JpcapCaptor.openDevice(devices[Integer.parseInt("2")], 2000, false, 20);

		jpcap.loopPacket(-1, tcpobj);
		//}
	}
                        
}
